# -*- coding: utf-8 -*-
"""DIP_A2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14BVy9LaW-a9ohjBR0uiPk4zfMMIC7fUr
"""

# Commented out IPython magic to ensure Python compatibility.
from PIL import Image
import numpy as np
from math import *
import matplotlib.pyplot as plt
# %matplotlib inline

"""Q1"""

img = Image.open("x5.bmp")
barbara = np.array(img)

barbara = np.delete(barbara,slice(200,512),0)
barbara = np.delete(barbara,slice(200,512),1)

barbara.shape

final_img = barbara.astype(np.uint8)
final_img = Image.fromarray(final_img)
final_img = final_img.convert('L')

final_img

def nearest_four(x,y,grid):
  if((floor(x)==ceil(x)) and (floor(y)==ceil(y))):
    return "exact"
  if(floor(x)==ceil(x)):
    return [(x,floor(y),grid[floor(x)][floor(y)]),
          (x+1,floor(y),grid[floor(x)+1][floor(y)]),
          (x,ceil(y),grid[floor(x)][ceil(y)]),
          (x+1,ceil(y),grid[floor(x)+1][ceil(y)])]
  if(floor(y)==ceil(y)):
    return [(floor(x),y,grid[floor(x)][floor(y)]),
          (ceil(x),y,grid[ceil(x)][floor(y)]),
          (floor(x),y+1,grid[floor(x)][floor(y)+1]),
          (ceil(x),y+1,grid[ceil(x)][floor(y)+1])]
  return [(floor(x),floor(y),grid[floor(x)][floor(y)]),
          (ceil(x),floor(y),grid[ceil(x)][floor(y)]),
          (floor(x),ceil(y),grid[floor(x)][ceil(y)]),
          (ceil(x),ceil(y),grid[ceil(x)][ceil(y)])]

def bilinear_interpolation(x, y, points):
    # print("hi")
    (x1, y1, p1) = points[0]
    (x2, y2, p2) = points[1]
    (x3, y3, p3) = points[2]
    (x4, y4, p4) = points[3]
    X=np.array([[x1,y1,x1*y1,1],[x2,y2,x2*y2,1],[x3,y3,x3*y3,1],[x4,y4,x4*y4,1]])
    V = np.array([p1,p2,p3,p4])
    X_inv = np.linalg.inv(X)
    A = np.matmul(X_inv,V)
    return A[0]*x+A[1]*y+A[2]*x*y+A[3]

tx=50
trans = np.array([[1,0,0],[0,1,0],[tx,tx,1]])
ten=pi/18
rot = np.array([[cos(ten),-sin(ten),0],[sin(ten),cos(ten),0],[0,0,1]])
T = np.matmul(trans,rot)
print("The transformation matrix is")
print(T)

def transform_xy(x,y):
  trfm = np.matmul(np.array([x,y,1]),np.linalg.inv(T))
  # print(trfm)
  return trfm

X=[]
Y=[]
for x in range(300):
  for y in range(300):
    trf = transform_xy(x,y)
    X.append(trf[0])
    Y.append(trf[1])
plt.scatter(X,Y,marker='^')
plt.rcParams['figure.figsize'] = [10, 10]
ax = plt.gca()
plt.title("complete mapping to input grid")
ax.set_ylim(ax.get_ylim()[::-1])
plt.show()

X=[]
Y=[]
for x in range(300):
  for y in range(300):
    trf = transform_xy(x,y)
    if(trf[0]<0 or trf[1]<0):
      continue
    X.append(trf[0])
    Y.append(trf[1])
plt.scatter(X,Y,marker='^')
plt.rcParams['figure.figsize'] = [10, 10]
ax = plt.gca()
plt.title("showing only positive coordinates")
ax.set_ylim(ax.get_ylim()[::-1])
plt.show()

initial_img = barbara
initial_img = np.pad(initial_img, (0,400), 'constant')
print(initial_img.shape)
length = 300
breadth = 300
final_img = np.zeros((length,breadth))
count=0
for x in range(length):
  for y in range(breadth):
    trfm = transform_xy(x,y)
    # print(trfm[0],trfm[1])
    count +=1
    if(trfm[0]<0 or trfm[1]<0 or trfm[0]>300 or trfm[1]>300):
      final_img[x][y]=255
      continue
    if(nearest_four(trfm[0],trfm[1],initial_img)=="exact"):
      final_img[x][y]=initial_img[trfm[0]][trfm[1]]
    else:
      final_img[x][y]=bilinear_interpolation(trfm[0],trfm[1],nearest_four(trfm[0],trfm[1],initial_img))
print(count)

final_img = final_img.astype(np.uint8)
final_img = Image.fromarray(final_img)
final_img = final_img.convert('L')
final_img

"""Q2"""

def transform2_xy(x,y):
  trfm = np.matmul(np.array([x,y,1]),T)
  return trfm

X=[]
Y=[]
for x in range(300):
  for y in range(300):
    trf = transform_xy(x,y)
    if(trf[0]<0 or trf[1]<0):
      continue
    X.append(trf[0])
    Y.append(trf[1])
plt.scatter(X,Y,marker='^')
plt.rcParams['figure.figsize'] = [10, 10]
ax = plt.gca()
plt.title("mapping output coordinates to input grid")
ax.set_ylim(ax.get_ylim()[::-1])
plt.show()

initial_img = final_img
initial_img = np.pad(initial_img, (0,400), 'constant')
print(initial_img.shape)
length = 200
breadth = 200
final_img = np.zeros((length,breadth))
for x in range(length):
  for y in range(breadth):
    trfm = transform2_xy(x,y)
    # print(trfm[0],trfm[1])
    # if(trfm[0]<0 or trfm[1]<0 or trfm[0]>300 or trfm[1]>300):
    #   continue
    if(nearest_four(trfm[0],trfm[1],initial_img)=="exact"):
      final_img[x][y]=initial_img[trfm[0]][trfm[1]]
    else:
      final_img[x][y]=bilinear_interpolation(trfm[0],trfm[1],nearest_four(trfm[0],trfm[1],initial_img))

final_img = final_img.astype(np.uint8)
final_img = Image.fromarray(final_img)
final_img = final_img.convert('L')
final_img

"""q3"""

img = Image.open("x5.bmp")
barbara = np.array(img)
img

c = 255 / np.log(1 + np.max(barbara))
log_image = 255 / np.log(1 + np.max(barbara))* (np.log(barbara + 1))
final_img = log_image.astype(np.uint8)
final_img = Image.fromarray(final_img)
final_img = final_img.convert('L')
final_img

a = barbara
fig = plt.figure(figsize =(10, 7))
hist, bins = np.histogram(a, bins = np.arange(256))

print(barbara.shape)
hist = hist/262144
hist.sum()

plt.plot(hist,bins[1:])
plt.title("Original histogram")
plt.show()

cdf = np.cumsum(hist)
plt.plot(bins[1:],cdf)
plt.title("CDF of initial image")
plt.show()

L=256
T_r = (L-1)*cdf

a = log_image
fig = plt.figure(figsize =(7, 7))
log_hist, bins = np.histogram(a, bins = np.arange(256))
log_hist = log_hist/262144

plt.plot(log_hist,bins[1:])
plt.title("Log transform histogram")
plt.show()

cdf_log = np.cumsum(log_hist)
G_s = (L-1)*cdf_log
plt.plot(bins[1:],cdf_log)
plt.show()

print(T_r.shape,G_s.shape)

mapping = np.zeros(255)
for r in range(255):
  maxi = 100000
  for s in range(255):
    if(abs(T_r[r]-G_s[s])<maxi):
      maxi = abs(T_r[r]-G_s[r])
      mapping[r]=s
print(mapping)

barabara_eq = barbara

for r in range(512):
  for c in range(512):
    if(barbara[r][c]==0):
      continue
    barabara_eq[r][c] = mapping[barbara[r][c]-1]

final_img = barabara_eq.astype(np.uint8)
final_img = Image.fromarray(final_img)
final_img = final_img.convert('L')
final_img